Sita.sys <- array(rep(10*diag(m),nhh), dim=c(m,m,nhh))
# step4・壽闘莨ｼ螳ｶ蠎ｭ蜀・惠蠎ｫ繧定ｦ丞ｮ壹☆繧九◆繧√・繝代Λ繝｡繧ｿ繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ縺ｮ縺溘ａ縺ｮ繝・・繧ｿ譫
# ﾎｸ縺・螟画焚繧呈戟縺､譎ゅ・繝吶け繝医Ν縺ｧ縺ｯ縺ｪ縺塾atrix縺ｫ縺吶ｋ縺薙→
Lsita.dlt <- rep(0,nhh)
Lsita.lmbd <- rep(0,nhh)
Hdlt <- matrix(rep(0,nD),nvar,)
Hlmbd <- matrix(rep(0,nD),nvar,)
Vsita.dlt <- 0.01*diag(nvar)
Vsita.lmbd <- 0.01*diag(nvar)
Sita.dlt <- rep(0,nhh)
Sita.lmbd <- rep(0,nhh)
sigma.dlt <- 0.01*diag(nvar)
sigma.lmbd <- 0.01*diag(nvar)
rej.dlt <-rep(0,nhh)
rej.lmbd <-rep(0,nhh)
##---------------------------------------------------------
## 蛻晄悄蛟､縺ｮ險ｭ螳・-----------------------------
# step1逕ｨ
Xs <- array(double(nhh*zc*TIMES), dim=c(nhh, zc, TIMES))
sigma <- 1.0
# ut縺ｯat,bt繧堤匱逕溘＆縺帙ｋ縺溘ａ縺ｫ菴懊▲縺滓闘莨ｼ繝・・繧ｿ.譛ｬ譚･縺ｯ蠢・ｦ√↑縺・ut <- array(runif(nhh*TIMES, min=-1, max=1), dim=c(nhh, TIMES))
# step2逕ｨ
param <- FGHset(0, 1, SEASONALYTY, 0, nz)
L <- 1
R <- diag(L)
F <- param$MatF
G <- param$MatG
#繧ｷ繧ｹ繝・Β繝｢繝・Ν縺ｮ蛻・淵繧貞倶ｺｺ縺斐→縺ｫ譬ｼ邏阪☆繧区棧
Q0 <-param$MatQ %o% rep(1,nhh)
Q <- Q0
# step3逕ｨ
mu <- 0
sigs <- 1
##-------------------------------------------
## 蛻・妙遽・峇縺ｮ謖・ｮ・at <- ifelse(ut<0, -100, 0)
bt <- ifelse(ut<0, 0, 100)
##-------------------
udraw <- array(double(nhh*TIMES*RP),dim=c(nhh,TIMES,RP))
## 繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ縺ｮ繝ｫ繝ｼ繝・for(nd in 1:RP){
for(hh in 1:nhh){
# step3縺ｮ髫主ｷｮ險育ｮ励・蜥後・險育ｮ励〒菴ｿ逕ｨ縺吶ｋ螟画焚縺ｮ蛻晄悄蛹・dift <- 0
difw <- 0
difbeta <- rep(0,nz)
# step4縺ｮﾎｸ縺ｮ莠句ｾ悟・蟶・き繝ｼ繝阪Ν縺ｮ隨ｬ荳鬆・・蜥瑚ｨ育ｮ玲凾菴ｿ逕ｨ縺吶ｋ螟画焚縺ｮ蛻晄悄蛹・Lsita <- 0
for(t in 1:TIMES){
# step1--------------------------------------------------
u[hh,t] <- rtnorm(Ztld[hh,,t]%*%Xs[hh,,t], sigma, at[hh,t], bt[hh,t])
udraw[hh,t,nd] <- u[hh,t]
#------------------------------------------------------------
}
## step2縺ｮ繧ｷ繧ｹ繝・Β繝｢繝・Ν繝代Λ繝｡繝ｼ繧ｿ縺ｮ險育ｮ・---------------------
# TAU2縺ｮ譛蟆､謗ｨ螳壹ｒ豎ゅａ繧区焚蛟､險育ｮ・-----------------------------
ISW <- 0
tau0 <- c(TAU21=Sita.sys[1,1,hh],TAU22=Sita.sys[2,2,hh],
TAU23=Sita.sys[3,3,hh],TAU24=Sita.sys[4,4,hh],
TAU25=Sita.sys[5,5,hh])
LLF1 <- optim(tau0, fn=LogL, y=u[hh,], F=F, H=Ztld[hh,,], G=G, R=R,
limy=limy, ISW=ISW, k=zc, m=m , N=TIMES , Q0=Q0[,,hh],
method ="L-BFGS-B",
lower = 1e-4, upper = 1e2,
control=list(fnscale=-1))
# TAU2縺ｮ譛蟆､謗ｨ螳・TAU2 <- LLF1$par
# 繧ｫ繝ｫ繝槭Φ繝輔ぅ繝ｫ繧ｿ
Q <- Qset(Q0[,,hh] ,TAU2); XF0 <- numeric(zc)
VF0 <- 10 * diag(zc); OSW <- 1
LLF2 <- KF(u[hh,], XF0, VF0, F, Ztld[hh,,], G, Q, R, limy, ISW, OSW, zc, TIMES)
XPS <- LLF2$XPS; XFS <- LLF2$XFS
VPS <- LLF2$VPS; VFS <- LLF2$VFS
SIG2 <- LLF2$Ovar; GSIG2 <- 1
# 蟷ｳ貊大喧 ----------------------------------------------------------
LLF3 <- SMO(XPS, XFS, VPS, VFS, F, GSIG2, 1, SEASONALYTY, 1, zc, TIMES)
Xs[hh,,] <- LLF3$XSS
#------------------------------------------------------------
for(t in 1:TIMES){
# step3縺ｮ髫主ｷｮ縺ｮ險育ｮ・-------------------------------------
if(t>1){
dift <- dift + (Xs[hh,1,t] - Xs[hh,1,t-1])^2
difw <- difw + (Xs[hh, 2, t]+sum(Xs[hh, 2:SEASONALYTY, t-1]))^2
for(d in 1:nz){
difbeta[d] <- difbeta[d] + (Xs[hh,SEASONALYTY+d,t]
- Xs[hh,SEASONALYTY+d,t-1])^2
}
}
#--------------------------------------------------------
# step4縺ｮ蜉ｹ逕ｨ蛟､縺ｮ隱､蟾ｮ險育ｮ・step4縺ｮﾎｸ縺ｮ蟆､蠎ｦ險育ｮ・------------
Lsita <- Lsita + (u[hh,t] - t(Ztld[hh,,t])%*%Xs[hh,,t])^2
#--------------------------------------------------------
}
# step3--------------------------------------
Sita.sys[1,1,hh] <- irgamma(1, (nu0+TIMES)/2, (s0+dift)/2)
Sita.sys[2,2,hh] <- irgamma(1, (nu0+TIMES)/2, (s0+difw)/2)
for(d in 1:nz){
Sita.sys[2+d,2+d,hh] <- irgamma(1, (nu0+TIMES)/2, (s0+difbeta[d])/2)
}
#--------------------------------------------
### step4--------------------------------------
## dlt蛛ｴ縺ｮ險育ｮ・# 迴ｾ迥ｶ縺ｮﾎｸ繧堤｢ｺ菫昴☆繧・old.sita.dlt <- Sita.dlt[hh]
# 譁ｰ縺励＞ﾎｸ繧偵し繝ｳ繝励Μ繝ｳ繧ｰ・磯・豁ｩ繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ・・new.sita.dlt <- Sita.dlt[hh] + rnorm(1, 0, sigma.dlt)
# 蟆､蠎ｦ縺ｮ險育ｮ暦ｼ亥ｯｾ謨ｰ蟆､蠎ｦ縺ｮ蝣ｴ蜷医・繝､繧ｳ繝薙い繝ｳ縺ｧ隱ｿ謨ｴ・・new.Lsita.dlt <- Lsita + Nkernel(new.sita.dlt, Hdlt, D[hh,], Vsita.dlt)
new.Lsita.dlt <- exp(-0.5*new.Lsita.dlt)
old.Lsita.dlt <- Lsita + Nkernel(old.sita.dlt, Hdlt, D[hh,], Vsita.dlt)
old.Lsita.dlt <- exp(-0.5*old.Lsita.dlt)
# MH繧ｹ繝・ャ繝・alpha <- min(1, new.Lsita.dlt/old.Lsita.dlt)
if(alpha=='NaN') alpha <- -1
uni <- runif(1)
if(uni < alpha){
Sita.dlt[hh] <- new.sita.dlt
}else{
rej.dlt[hh] <- rej.dlt[hh] + 1
}
## lmbd蛛ｴ縺ｮ險育ｮ・# 迴ｾ迥ｶ縺ｮﾎｸ繧堤｢ｺ菫昴☆繧・old.sita.lmbd <- Sita.lmbd[hh]
# 譁ｰ縺励＞ﾎｸ繧偵し繝ｳ繝励Μ繝ｳ繧ｰ・磯・豁ｩ繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ・・new.sita.lmbd <- Sita.lmbd[hh] + rnorm(1, 0, sigma.lmbd)
# 蟆､蠎ｦ縺ｮ險育ｮ暦ｼ亥ｯｾ謨ｰ蟆､蠎ｦ縺ｮ蝣ｴ蜷医・繝､繧ｳ繝薙い繝ｳ縺ｧ隱ｿ謨ｴ・・new.Lsita.lmbd <- Lsita + Nkernel(new.sita.lmbd, Hlmbd, D[hh,], Vsita.lmbd)
new.Lsita.lmbd <- exp(-0.5*new.Lsita.lmbd)
old.Lsita.lmbd <- Lsita + Nkernel(old.sita.lmbd, Hlmbd, D[hh,], Vsita.lmbd)
old.Lsita.lmbd <- exp(-0.5*old.Lsita.lmbd)
# MH繧ｹ繝・ャ繝・alpha <- min(1, new.Lsita.lmbd/old.Lsita.lmbd)
if(alpha=='NaN') alpha <- -1
uni <- runif(1)
if(uni < alpha){
Sita.lmbd[hh] <- new.sita.lmbd
}else{
rej.lmbd[hh] <- rej.lmbd[hh] + 1
}
#--------------------------------------------
}
### step5--------------------------------------
## dlt蛛ｴ縺ｮ邂怜・----
# 螟壼､蛾乗ｭ｣隕丞・蟶・・繝代Λ繝｡繧ｿ縺ｮ邂怜・
Hhat.dlt <- solve(crossprod(D)) %*% t(D) %*% Sita.dlt
Dtld <- solve(crossprod(D) + A0) %*% (crossprod(D) %*% Hhat.dlt + A0%*%m0)
rtld <- as.vector(Dtld)
sig <-  (crossprod(D) + A0) %o% Vsita.dlt # %o%縺ｮ鬆・・蜑榊ｾ後ｒ螟峨∴繧九・縺ｯ繝繝｡
# 螟壼､蛾乗ｭ｣隕丞・蟶・〒繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ
Hdlt <- rmvnorm(nvar, rtld, as.matrix(data.frame(sig)))
##-----------------
## lmbd蛛ｴ縺ｮ邂怜・----
# 螟壼､蛾乗ｭ｣隕丞・蟶・・繝代Λ繝｡繧ｿ縺ｮ邂怜・
Hhat.lmbd <- solve(crossprod(D)) %*% t(D) %*% Sita.lmbd
Dtld <- solve(crossprod(D) + A0) %*% (crossprod(D) %*% Hhat.lmbd + A0%*%m0)
rtld <- as.vector(Dtld)
sig <-  (crossprod(D) + A0) %o% Vsita.lmbd # %o%縺ｮ鬆・・蜑榊ｾ後ｒ螟峨∴繧九・縺ｯ繝繝｡
# 螟壼､蛾乗ｭ｣隕丞・蟶・〒繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ
Hlmbd <- rmvnorm(nvar, rtld, as.matrix(data.frame(sig)))
##-----------------
#--------------------------------------------
### step6--------------------------------------
##dlt蛛ｴ縺ｮ邂怜・
# 騾・え繧｣繝・す繝｣繝ｼ繝亥・蟶・・繝代Λ繝｡繧ｿ縺ｮ邂怜・
div <- (Sita.dlt - D%*%matrix(Hdlt,nD,nvar))
S <- crossprod(div)
# 騾・え繧｣繝・す繝｣繝ｼ繝亥・蟶・〒繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ
Vsita.dlt <- riwish(f0 + nhh, V0 + S)
##------------
##lmbd蛛ｴ縺ｮ邂怜・
# 騾・え繧｣繝・す繝｣繝ｼ繝亥・蟶・・繝代Λ繝｡繧ｿ縺ｮ邂怜・
div <- (Sita.lmbd - D%*%matrix(Hlmbd,nD,nvar))
S <- crossprod(div)
# 騾・え繧｣繝・す繝｣繝ｼ繝亥・蟶・〒繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ
Vsita.lmbd <- riwish(f0 + nhh, V0 + S)
##------------
#--------------------------------------------
}
rtnorm(Ztld[1,,]%*%Xs[1,,], sigma, at[1,], bt[1,])
Ztld[1,,]%*%Xs[1,,]
t(Ztld[1,,])%*%Xs[1,,]
rtnorm(t(Ztld[1,,])%*%Xs[1,,], sigma, at[1,], bt[1,])
rtnorm(t(Ztld[1,,1])%*%Xs[1,,1], sigma, at[1,1], bt[1,1])
Ztld[1,,1]
rtnorm(t(Ztld[1,,])%*%Xs[1,,], sigma, at[1,], bt[1,])
rtnorm(t(Ztld[1,,])%*%Xs[1,,], sigma, at[1,], bt[1,])
rtnorm(t(t(Ztld[1,,])%*%Xs[1,,]), sigma, at[1,], bt[1,])
simbprobit=function(X,beta){}
simbprobit=function(X,beta){
y=ifelse((X%*%beta+rnorm(nrow(X)))<0,0,1)
list(X=X,y=y,beta=beta)
}
nobs<-200
X<-cbind(rep(1,nobs), runif(nobs), runif(nobs))
beta<-c(0,1,-1)
simout<-simbprobit(X,beta)
simout$y
a<- ifelse(y==0,-100,0)
y<-simout$y
a<- ifelse(y==0,-100,0)
a
head(a)
head(at)
head(at[1,])
rtnorm(t(Ztld[1,,])%*%Xs[1,,], sigma, t(at[1,]), t(bt[1,]))
rtnorm(t(t(Ztld[1,,])%*%Xs[1,,]), sigma, t(at[1,]), t(bt[1,]))
X%*%beta
t(t(Ztld[1,,])%*%Xs[1,,])
t(Ztld[1,,])%*%Xs[1,,]
t(t(Ztld[1,,])%*%Xs[1,,])
for(t in 1:TIMES){
# step1--------------------------------------------------
u[hh,t] <- rtnorm(Ztld[hh,,t]%*%Xs[hh,,t], sigma, at[hh,t], bt[hh,t])
udraw[hh,t,nd] <- u[hh,t]
#------------------------------------------------------------
}
Sita.sys0 <- rep(10.0, m)
Sita.sys0
x<- (1,2,3,4,5)
x <- c(1,2,3,4,5)
cumsum(x)
(x>=2)
which.max(x>=2)
which.max(x>=4)
which.max(x>=3.2)
const <- matrix(0,4,3)
const
diag(const) <-1
const
library(Matching)
data(lalonde)
logi <- glm(treat ~age + educ + black + hisp + married + nodegr +
re74 + re75 + u74 + u75, family=binomial, data=lalonde)
ivec1 <- lalonde$treat
ivec2 <- rep(1, nrow(lalonde)) - ivec1
ivec <- cbind(ivec1, ivec2)
install.packages(Matching)
install.packages("Matching")
library(Matching)
data(lalonde)
logi <- glm(treat ~age + educ + black + hisp + married + nodegr +
re74 + re75 + u74 + u75, family=binomial, data=lalonde)
ivec1 <- lalonde$treat
ivec2 <- rep(1, nrow(lalonde)) - ivec1
ivec <- cbind(ivec1, ivec2)
ivec
logi
logi$fitted
head(ivec1)
head(ivec2)
head(ivec)
tail(ivec)
head(logi$fitted)
length(ivec1)
head(iestp)
iestp <- iestp1 + iestp2  #蛯ｾ蜷代せ繧ｳ繧｢縺ｮ謗ｨ螳壼､縺ｮ騾・焚繧帝阪∩縺ｨ縺吶ｋ
Y78<- lalonde$re78
Tre<- lalonde$treat
mout<-Match()Y=Y78, Tr=Tre,X=logi$fitted
mout<-Match()Y=Y78, Tr=Tre,X=logi$fitted)
mout<-Match(Y=Y78, Tr=Tre,X=logi$fitted)
mout$se
mout$est.noadj
mout$mdata
mout$index.dropped
mout$index.treated
mout$index.control
length(mout$index.control)
length(mout$index.control)
unique(mout$index.control)
sort(unique(mout$index.control))
lengty(mout$index.treated
length(mout$index.treated)
length(sort(unique(mout$index.control)))
length(sort(unique(mout$index.treated)))
length(ivec1)
mout$index.control
help(mout)
help(Matching)
help("Matching")
help(Matching)
help("Matching")
help("Match")
length(sort(unique(mout$index.treated)))
mout<-Match(Y=lalonde$re78, Tr=lalonde$treat, X=logi$fitted)
mout
mout<-Match(Y=lalonde$re78, Tr=lalonde$treat, X=logi$fitted)
head(mout$index.treated)
head(mout$index.control)
length(mout$index.treated)
length(mout$index.control)
logi$fitted
logi$fitted[1]
logi$fitted[1,357]
logi$fitted[357]
logi$fitted[c(1,357)]
lalonde[c(1,357)]
lalonde[1]
lalonde[c(1,357)]
logi$fitted[c(1,357)]
lalonde[,1]
lalonde[1,1]
lalonde[1,2]
lalonde[:,1]
lalonde[1,]
lalonde[c(1357),]
lalonde[c(1,357),]
summary(logi)
install.packages('inline')
install.packages('Rcpp')
library(inline)
library(Rcpp)
src <- '
std::vector<std::string> s;
s.push_back("hello");
s.push_back("world");
return Rcpp::wrap(s);
'
hellofun <- cxxfunction(body = src, includes = '', plugin = 'Rcpp', verbose = FALSE)
cat(hellofun(), '\n')
system('g++ -v')
library(Rcpp)
library(inline)
library(Rcpp)
library()
library
library()
install.packages("Rcpp")
library(Rcpp)
src <- '
+ std::vector<std::string> s;
+ s.push_back("hello");
+ s.push_back("world");
+ return Rcpp::wrap(s);
+ '
src <- '
std::vector<std::string> s;
s.push_back("hello");
s.push_back("world");
return Rcpp::wrap(s);
'
hellofun <- cxxfunction(body = src, includes = '', plugin = 'Rcpp', verbose = FALSE)
cat(hellofun(), '\n')
Sys.setenv(R_MAKEVARS_USER='')
options(repos = c(getOption("repos"), rstan = "http://wiki.stan.googlecode.com/git/R"))
install.packages('rstan', type = 'source')
library(Rcpp)
install.packages('rstan', type = 'source')
library(glmmML)
install.packages("glmmML")
library(glmmML)
# read data
d <- read.csv(url("http://hosho.ees.hokudai.ac.jp/~kubo/stat/iwanamibook/fig/hbm/data7a.csv"))
d
rep(8,2)
N<-rep(8,nrow(d))
N<-as.frame(rep(8,nrow(d)))
data <- data.frame(N=N, id=d$id, y=d$y)
data
data <- data.frame(N=N, id=d$id, y=d$y, x=x)
x<-rep(2:6,each=20) # iterate 20times
data <- data.frame(N=N, id=d$id, y=d$y, x=x)
data
res <- glmmML(cbind(y, N-y))~x, data=data, family=binomial, cluster=id)
res <- glmmML(cbind(y, N-y)~x, data=data, family=binomial, cluster=id)
summary(res)
help(glmmML)
res <- glmmML(cbind(y, N-y)~x, data=data, family=binomial, cluster=id,method="ghq")
res
res.predict
predict(result, type="response")
predict(res, type="response")
help(predict)
data
res$coefficients
res$coefficients[1]
res$coefficients[2]
data
c(1,data$x)
data.frame(rep(1length(data$x)),data$x)
data.frame(rep(1,length(data$x)),data$x)
data.frame(i=rep(1,length(data$x)),x=data$x)
dd <- data.frame(i=rep(1,length(data$x)),x=data$x)
dd%in%res$coefficients
dd%*%res$coefficients
dd%*%matrix(res$coefficients,2,1)
matrix(res$coefficients,2,1)
as.matrix(dd)%*%matrix(res$coefficients,2,1)
q <- as.matrix(dd)%*%matrix(res$coefficients,2,1)
logit_q <- logistic(q)
function
logistic <- function(z){ 1/(1+exp(-z))}
logit_q <- logistic(q)
logit_q
(pred <- logistic(q)*N)
q
logistic(q)
logit_q <- logistic(q)
(pred <- logit_q*N)
library(MASS, quietly=TRUE)
# MM inference
brain_standerd <- (Animals$brain - mean(Animals$brain))/sd(Animals$brain)
body_standerd <- (Animals$body- mean(Animals$body))/sd(Animals$body)
model_mm <- rlm(brain_standerd ~ body_standerd, Animals, method="MM")
model_mm$coefficients
model_mm$w
plot(body_standerd, brain_standerd, main=name)
abline(model_mm)
brain_standerd
write.table(model_mm$w)
write.table("D:/RW/",model_mm$w)
write.table("D:/RW/test.csv",model_mm$w)
write.csv(model_mm$w,"D:/RW/test.csv")
library(igraph)
library("igraph")
install.packages("igraph")
library("igraph")
igraph(ARPACK)
ARPACK()
help(ARPACK)
svd
mat <- matrix(c(1,0,0,2,0,1,1,0,2,1,0,0),nrow=4,byrow=T)
mat
mat.svd <- svd(mat)
mat.svd$d
mat.svd$u
mat.svd$v
mat%*%mat.svd$v
mat%*%mat.svd$v[,:2]
mat%*%mat.svd$v(,:2)
x<-mat%*%mat.svd$v
x
x[,:2]
x[,1:2]
svd(x[,1:2])$d
mat.svd$d
uniform(0,1)
duniform(0,1)
dunif(0,1)
dunif(0,2)
dunif(2)
dunif(3)
dunif(4)
dunif(0,1,5)
help(dunif)
runif(20)
runif(0,1,20)
floor(runif(20))
floor(runif(20)+0.1)
floor(runif(20)+0.2)
floor(runif(30)+0.2)
floor(runif(40)+0.2)
floor(runif(40)+0.3)
mat <- matrix(floor(runif(500000)+0.3),nrow=5000,byrow=T)
mat.svd <- svd(mat)
mat.svd$d
mat.svd$v
mat%*%mat.svd$v
mat%*%mat.svd$v[,1:10]
mat%*%(mat.svd$v[,1:10])
mat.svd$d/sum(mat.svd$d)
cumsum( mat.svd$d/sum(mat.svd$d) )
setwd("D:/RW/stan/tmemo")
library(rstan)
set_cppo("fast")
library(doSNOW)
library(foreach)
cl<-makeCluster(4)
# read data
d <- read.csv("tmemo.csv")
N<-nrow(d)
N_col<-ncol(d)
Y<-d[,1]
X<-d[,4:N_col]
minutes<-d[,2]
X_M<-d[,3]
N_col<-ncol(X)
v0 <- matrix(0,nrow=N_col, ncol=N_col)
for(i in 1:N_col){ v0[i,i]<-100}
dat<-list(Y=Y, X=X, minutes=minutes, N=N, N_col=N_col, X_M=X_M, v0=v0)
## parallel processing each chain of stan
# do not sampling. just create model.
fit0<-stan(file='tmemo_hie.stan', data=dat, chains=0)
sflist2<-foreach(i=1:4,.packages="rstan") %dopar% {
stan(fit=fit0, data=dat, iter=1000, thin=3,
pars = c("beta"),
chains=1, chain_id=i, refresh=-1)
}
sigma0 <- matrix(0,nrow=N_col, ncol=N_col)
for(i in 1:N_col){ sigma[i,i]<-100}
dat<-list(Y=Y, X=X, minutes=minutes, N=N, N_col=N_col, X_M=X_M, v0=v0, sigma0=sigma0)
for(i in 1:N_col){ sigma0[i,i]<-100}
dat<-list(Y=Y, X=X, minutes=minutes, N=N, N_col=N_col, X_M=X_M, v0=v0, sigma0=sigma0)
fit0<-stan(file='tmemo_hie.stan', data=dat, chains=0)
sflist2<-foreach(i=1:4,.packages="rstan") %dopar% {
stan(fit=fit0, data=dat, iter=1000, thin=3,
#pars = c("beta"),
chains=1, chain_id=i, refresh=-1)
}
d <- read.csv("tmemo_test.csv")
N<-nrow(d)
N_col<-ncol(d)
Y<-d[,1]
X<-d[,4:N_col]
minutes<-d[,2]
X_M<-d[,3]
N_col<-ncol(X)
v0 <- matrix(0,nrow=N_col, ncol=N_col)
for(i in 1:N_col){ v0[i,i]<-100}
sigma0 <- matrix(0,nrow=N_col, ncol=N_col)
for(i in 1:N_col){ sigma0[i,i]<-100}
dat<-list(Y=Y, X=X, minutes=minutes, N=N, N_col=N_col, X_M=X_M, v0=v0, sigma0=sigma0)
fit0<-stan(file='tmemo_hie.stan', data=dat, chains=0)
sflist2<-foreach(i=1:4,.packages="rstan") %dopar% {
stan(fit=fit0, data=dat, iter=1000, thin=3,
#pars = c("beta"),
chains=1, chain_id=i, refresh=-1)
}
f3<-sflist2stanfit(sflist2)
stopCluster(cl)
apply(extract(f3)$alpha,2,median)
plot(f3)
traceplot(f3)
summary()f3
summary(f3)
sf3
f3
